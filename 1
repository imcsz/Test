CRG
CRG，clock reset generater，又称时钟复位产生器。一般情况下，CRG模块的输出信号分为三种类型：时钟，复位，使能。如果说，CPU是SOC芯片的大脑，那么CRG就是SOC的心脏，源源不断的为SOC输送血液，起搏振动。CRG模块的主要作用就是为全芯片提供相应的时钟复位，以及时钟使能信号。


21、OCC
on-chip clock，一种dft测试模式所需要的时钟电路。


CTS之前的准备动作

梳理时钟结构，规划时钟树的方法。时钟树是从后往前做
Place结果是正确的，cell都被摆放在了正确的位置，没有overlap；
所有macro都被fix住了；set_dont_touch_placement 【all_macro_cells】
Clean原有时钟树上面的buf/invter   remove_clock_tree


6.       PR工具是如何做时钟树的

（1）       时钟树是从后往前做的；

（2）       Create_clock或者generated_clock并没有区别，只要放在了compile_clock_tree的list中都是把这个时钟的source点作为时钟树的起点；

（3）       时钟树是否需要balance，是根据sdc中的时钟分组决定的；同步的时钟就会做balance，异步的时钟不balance，不管做树的先后顺序，都按照这个原则进行balance；所以如果前端约束中同步时钟但不想做balance（同一个源时钟，不同分频，但是没有路径交互），这个时钟pr人员需要自己修改sdc，重新设置set_clock_groups；做完时钟树之后，remove sdc，再读入前端sdc，进行sta分析；

（4）       做完后面的时钟树，再往上一级做树的时候，工具会计算后面的时钟树长度；如果上一级树需要balance，工具可以在上一级树上balance；

（5）       工具不能很好的识别internal pin，因为工具是基于位置来balance时钟树的，internal pin没有位置信息，会导致工具做出来的树，balance的不好。所以phy内部时钟要在phy的输出pin上定义generated时钟。这样工具就能从generated点开始做树

（6）       什么情况下需要人工参与一步一步的做树？什么情况下可以一口气让工作做树？

时钟复杂，需要人工参与，定好时钟树方案；如果时钟非常简单，只有单一的时钟域，且时钟数量较少，就可以让工具完成

（7）       STA约束和CTS约束的区别？

STA只关心是否需要同步收敛时序。如果没有交互但是同源的时钟可以放在同一个时钟group，这样不影响sta。但是影响时钟树。

CTS关心同步的时钟是否需要blance。因此，同步时钟，但是没有路径交互的时钟，可以不balance。



3：Recovery/removal

Recovery：复位信号无效之后到时钟有效沿之前的最小时间。

Remove：时钟有效沿来之后到复位无效之前的最小时间。

检查的目的：防止时钟有效沿和复位信号撤离在时间上相距太近，从而导致寄存器无法判断是该继续复位还是打入新的值。
