CRG
CRG，clock reset generater，又称时钟复位产生器。一般情况下，CRG模块的输出信号分为三种类型：时钟，复位，使能。如果说，CPU是SOC芯片的大脑，那么CRG就是SOC的心脏，源源不断的为SOC输送血液，起搏振动。CRG模块的主要作用就是为全芯片提供相应的时钟复位，以及时钟使能信号。


21、OCC
on-chip clock，一种dft测试模式所需要的时钟电路。


CTS之前的准备动作

梳理时钟结构，规划时钟树的方法。时钟树是从后往前做
Place结果是正确的，cell都被摆放在了正确的位置，没有overlap；
所有macro都被fix住了；set_dont_touch_placement 【all_macro_cells】
Clean原有时钟树上面的buf/invter   remove_clock_tree


6.       PR工具是如何做时钟树的

（1）       时钟树是从后往前做的；

（2）       Create_clock或者generated_clock并没有区别，只要放在了compile_clock_tree的list中都是把这个时钟的source点作为时钟树的起点；

（3）       时钟树是否需要balance，是根据sdc中的时钟分组决定的；同步的时钟就会做balance，异步的时钟不balance，不管做树的先后顺序，都按照这个原则进行balance；所以如果前端约束中同步时钟但不想做balance（同一个源时钟，不同分频，但是没有路径交互），这个时钟pr人员需要自己修改sdc，重新设置set_clock_groups；做完时钟树之后，remove sdc，再读入前端sdc，进行sta分析；

（4）       做完后面的时钟树，再往上一级做树的时候，工具会计算后面的时钟树长度；如果上一级树需要balance，工具可以在上一级树上balance；

（5）       工具不能很好的识别internal pin，因为工具是基于位置来balance时钟树的，internal pin没有位置信息，会导致工具做出来的树，balance的不好。所以phy内部时钟要在phy的输出pin上定义generated时钟。这样工具就能从generated点开始做树

（6）       什么情况下需要人工参与一步一步的做树？什么情况下可以一口气让工作做树？

时钟复杂，需要人工参与，定好时钟树方案；如果时钟非常简单，只有单一的时钟域，且时钟数量较少，就可以让工具完成

（7）       STA约束和CTS约束的区别？

STA只关心是否需要同步收敛时序。如果没有交互但是同源的时钟可以放在同一个时钟group，这样不影响sta。但是影响时钟树。

CTS关心同步的时钟是否需要blance。因此，同步时钟，但是没有路径交互的时钟，可以不balance。


CTS学习总结（二）   
日期：2016-10-13 11:03 浏览：137 回复：0
 

CTS是先插入buf，满足drc要求（transition/cap/fanout）。然后再resized，用来balance skew；最后是考虑insertion delay。DRC 》 skew 》 latency

CTS做树工具是从sink点开始往前做到source点。

CTS两大目的：1.DRC满足；2最小的skew和latency

CTS对skew和latency的默认设置：工具默认值是0；

最好不要将drc和skew设置太严格，这样会增加buf 级数，同时run time较长

时钟树最好使用rise/fall balance的buf，同时使用inverter对。

CTS阶段工具自动propagated时钟，不需要使用set_propagated_clock的命令；

工具在post-CTS阶段，最好将uncertainty去掉，否则工具会把实际的skew+uncertainty当做skew的最大值，不停的优化这个skew。疑问，CTS前期做树阶段不需要去掉吗？

工具认为的三种sink点的pin，以及工具处理方式：

stop pins；寄存器或者latch时钟端，可以认为是时钟树的终点。这些pin是会优化DRC，skew&latency。最重要的是这些pin需要优化是，只要在外部优化时钟树即可。

float pins: IP的时钟pin。类似stop pin，因为同样优化DRC，skew&latency。但是和stop pin不同点是需要考虑IP内部的latency来优化skew。

exclude（ignore）pins：CTS忽略skew&latency，只fix DRC。包括以下类型：

a.       时序cell的非时钟pin；

b.       输出端口

c.       没有fanout的组合逻辑cell的pin或者ICG的pin

d.       3态使能pin

e.       数据路径的mux的s端

f.        定义错误的时钟pin（包括没有反转信息的时钟pin，输出时钟没有

g.       常值的buf/inv的输入pin；



3：Recovery/removal

Recovery：复位信号无效之后到时钟有效沿之前的最小时间。

Remove：时钟有效沿来之后到复位无效之前的最小时间。

检查的目的：防止时钟有效沿和复位信号撤离在时间上相距太近，从而导致寄存器无法判断是该继续复位还是打入新的值。
