标准3 Clock Gating能力
实际上，并不是Clock Gating后的每一次翻转，都导致寄存器翻转。如上图所示，Gating cell的输出端翻转70次，而它驱动的三个寄存器的Q端只分别翻转了10次，5次和20次，这样看来直观的感觉是70次的翻转有些多余了，好像只要有35次就够了，这个比值反应了Clock Gating的能力，当然这是一个平均的统计结果，这为我们进一步优化代码提供了方向。如果Clock Gating能力比价差，我们可以看看是什么原因，有没有进一步优化的空间，或者看能不能采用我们后面介绍的Self-Gating方法。
标准4 Clock Gating扇出功耗
这个是最直接的标准，就是直接计算Clock Gating cell扇出cone上的功耗，包括时钟树上clock buffers和寄存器。Clock Gating cell在物理版图上的位置不同，对它能发挥的作用是有很大影响的，如下图所示：
 
    Clock Gating cell越接近时钟树的源端，节省的功耗越多，但这时使能端的timng就不是很好收敛，所以在没有timing问题的时候，尽量让ICG cell驱动更多的寄存器和时钟树buffer。
标准5 Clock tree翻转数量
就是计算某个时钟域时钟树上所有cell的翻转数量总和，可以作为我们优化时钟树功耗的评价标准。
标准6 clock tree翻转电容
一条net的翻转电容定义为net翻转次数与net电容的乘积，如下：
Switching Capacitance = Toggle count of net * Capacitance on the net
那么时钟网络的翻转电容就是所有时钟net的翻转电容总和。

以上标准的基础是为设计提供准确的时钟及翻转信息，可以通过仿真产生VCD波形，然后从波形中提取相关的翻转率信息。
这些标准为我们优化及评价Clock Gating和时钟树网络提供了依据。
Clock Gating及时钟树功耗优化方法
动态功耗是时钟树上的主要功耗，而动态功耗又分为Switch功耗和Internal功耗，我们看一下时钟树上那些因素影响他们。
时钟树上Switch功耗的影响因素主要包括：
	Switching capacitance
	Number of toggles
时钟树上Internal功耗的影响因素主要包括：
	Number of cells
	Size of cells
	Number of toggles
下面介绍一些后端最新的Clock Gating及时钟树功耗优化的方法。
Clock Gating的复制（duplication）或合并（merging）
综合阶段，如果一个ICG cell的fanout太大的化，可以通过set_clock_gating_style命令控制是否复制ICG cell。如果综合阶段没有对ICG的扇出进行控制，在后端实现的时候可以对ICG cell进行复制来控制扇出，如果综合阶段对ICG cell进行了复制，后端实现的时候可以对ICG cell进行合并。Clock Gating的合并及复制示意图如下所示。
 
 
复制ICG cell的好处为更容易收敛timing，并且时钟网络的skew比较小。
合并ICG cell的好处是更少的ICG cell数量，更小的时钟树功耗。
在没有timing问题的情况下，建议尽量合并ICG cell，这样虽然clock buffer的数量会增多，但大部分clock buffer会插到ICG cell之后，这样可以节省更多的功耗。在SD8XXX项目中，综合阶段没有控制ICG cell的扇出，即只要使能信号相同，不管fanout多大，都只插入一个ICG cell，在后端实现的时候Vendor也没有复制ICG cell，这样可以最大化减少时钟树的功耗。
Magnet Placement/Stacked Flop
Magnet Placement是后端实现工具的一个feature，它可以把ICG cell驱动的寄存器尽量place到ICG cell的周围，这样可以有效减少clock net上的电容，电容减少的同时，也可能把ICG cell本身的Size减少，从而降低时钟树的switch和internal功耗，Magnet Placement的示意图如下。
 
     Stacked Flop和Magnet Placement的原理相同，但Stacked Flop要求在后端实现的时候做的更细致，把寄存器按照规则的形状摆放，这样可以最小化走线长度，减少布线电容，如下图所示。
 
限制Clock gating/Register size
Clock gating cell有不同的驱动能力，驱动能力越大，消耗的功耗也越大。在2010年SUNG的一篇文章中1，测试了有20X和4X的ICG方案，测试结果显示，用4X的ICG cell，clock buffer的数量有所增加，这是可以预见的，因为需要增加额外的buffer驱动寄存器，但这些增加的buffer会放在ICG cell之后，如果ICG cell比较多的化，整体时钟树功耗是有所降低的，如下图所示。
自然的想到可不可以通过限制寄存器size来减少功耗呢？这个我们可以在后端实现的时候进行具体测试，文献1中提到能否降低功耗是设计相关的。
 
XOR Basics Self-Gating
前面介绍过，根据输入数据翻转的特点，并不是每一个时钟有效沿都导致寄存器翻转，XOR basic clock gating利用这个特点，比较寄存器的输入端和输出端，如果它们都是0或者都是1，则可以通过一个XOR门来关掉寄存器的时钟，如下图所示。
 
由图可以看出，在寄存器的输入和输出端引入一个XOR，XOR门的输出连接在新插入ICG的EN端，这样如果寄存器不翻转，则可以通过XOR门关掉寄存器时钟。
XOR basic clock gating 可以通过PR工具自动实现，但在实现时有一些限制条件。首先必须为工具提供准确的翻转率，这样工具才能选择在那些翻转率比较低的寄存器上插入self-gating，翻转率比较高的寄存器不适合插self-gating，这可以通过变量控制（cts_self_gating_dataTR_filter）。其次工具会考虑寄存器本身的功耗，如果这个寄存器本身消耗的功耗比较小，那么插入self-gating可能得不偿失，这个也可以通过变量控制（cts_self_gating_reg_power_filter）。还有就是会考虑对timing的影响，比如时序比较紧的路径，跨时钟域的路径，不插self clock gating等。
Useful Skew
传统的时钟树一般是要把时钟树做balance，把时钟skew做到最小，这样会产生一个问题，就是可能存在大量的寄存器在一个很小的时间窗口（最大clock skew）内同时翻转，即SSO（simultaneously switching outputs），产生很大的噪声，如果芯片中有敏感的模拟器件时，这种情况是不允许的。从功耗角度看，SSO会产生很大的瞬态功耗，可能会影响timing。
用Useful Skew方法可以有效的减少这种效应，它的基本思想是在不同的寄存器级别上插入不同的clock insertion delay，把寄存器翻转的时间窗拉大，如下图所示。
 
经过useful skew前后，瞬时功耗如下图所示.
 
上图中X坐标表示time，Y坐标表示power，蓝色表示做useful skew前的结果，红色表示useful skew后的结果，从图可以看出，useful skew后瞬时功耗在时间轴上被拉平了。
Useful Skew方法在SD8XXX项目中成功应用。
漏电功耗优化
随着工艺的缩小，漏电功耗在整个设计中所占的比例越来越重，漏电功耗主要由亚阀值漏电和栅极漏电组成，亚阀值漏电与阀值电压VT（threshold voltage）相关，VT越高，漏电越小，栅极漏电主要和栅长相关，栅长减小，栅极漏电增加。
 
根据上图，介绍几种常见的减少漏电功耗的方法。
Multi Threshold voltage库
最常用的减少漏电功耗的方法是采用Multi-Threshold库，目前工艺库都提供多种threshold电压的库，不同Multi vt库的特性如下表所示。
 
采用Multi-vt库优化漏电功耗的原则为在关键路径上用LVT的库，在非关键路径上用HVT的库，最终在speed和leakage power间达到平衡。
目前我们的流程主要是在综合阶段用RVT库或者HVT库，后端把时序不收敛的地方替换成LVT的库，把有时序余量的地方尽量替换成HVT的库，这是基本流程，但是leakage power优化可以在综合和后端每个步骤中应用，不同库，不同流程的组合最后得到的功耗值也不一样。在需要精细化控制leakage power的项目中，需要我们多测试一些流程的组合，得到较优化的leakage power。
下面借用文献2中不同流程组合，说明不同组合得到不同的leakage power结果。
Test1：DC综合时采用HVT和LVT库，综合时没有进行leakage power优化，在PR工具ICC中也没有进行任何leakage power优化，得到的统计结果如下表所示。
 
从表可以看出，LVT cell比例比较高，将近79%，并且99%的leakage power都是LVT cell消耗的。
Test2：综合阶段采用单一的HVT库，综合阶段尽量满足时序，但综合网表还是有一部分时序没有满足，在PR阶段，我们用HVT/RVT/LVT三种库，并且让ICC去优化leakage power，得到的结果如下表所示。
 
    从表可以看出，LVT cell的比例下降到49%，总体的leakage power为0.79mW，相比test1 leakage power降低31%。
Test3：综合阶段用DCT，物理约束读入ICC的def文件，综合阶段用HVT/RVT/LVT三种库进行timing和leakage优化，在PR阶段继续优化leakage power，得到的结果如下表所示。
 
     从表可以看出，LVT cell比例与test2比稍有降低，但LVT cell 的leakage power只有0.555mW，比test2中的0.77mW有很大程度的降低，这是因为当DC和ICC有较好的correlation时，DCT能对时序功耗进行比较好的优化，比如选取驱动比较小的cell等，从而得到较优的leakage power，整体leakage power与test1比能够降低50%左右。
Multi-Channel Length库
现在40nm及以下的工艺库，会提供Multi-Channel Length库来降低漏电功耗，不论芯片工作在active模式，还是idle模式，Multi-Channel Length库都能降低漏电功耗。
Short channel length器件比longer channel length器件提供更高的性能，但longer channel length可以有效的降低漏电电流，和Multi Vt库一样，关键路径上考虑用Short channel length器件，非关键路径上考虑用longer channel length器件，资料显示，用Multi-Channel Length器件能够降低30%左右的漏电功耗。
目前先进工艺库都是把Multi vt库和Multi-Channel Length库结合在一起提供，即对于各种不同VT库中，有分不同Multi-Channel Length的库，如下图所示，以40nm工艺为例，说明性能与漏电的关系。
 
上图横坐标表示不同类型库的性能，纵坐标表示漏电功耗，绿色表示HVT类型的库，蓝色表示SVT类型库，红色表示LVT类型库，对于同一种VT库，40/45/50表示不同的Channel Length。
上图中对于HVT40库与HVT50库相比，性能提升了25%，但漏电功耗增加了3.6倍。对于SVT50库与HVT40库相比，性能提升了29%，同时漏电功耗也降低了39%，同理LVT50库与SVT40库相比，也有类似的趋势，所以增加channel length并且降低VT是比较有竞争力的选择。
Long channel LVT器件与short channel SVT器件相比（或者long channel SVT器件与short channel HVT相比），具有更快的速度，更小的面积和更低的漏电功耗，用Long channel LVT器件做时钟驱动，可以减少时钟树的latency，从而减少时钟树上的OCV（on chip variation）。
综上所述，根据不同的speed和leakage要求，Multi Threshold voltage库和Multi-Channel Length库选择原则参考下图所示。
 
还有些其他降漏电功耗的技术，比如High-k metal gate，reverse bias等，这些技术与工艺强相关，比如TSMC 28nm工艺就采用High-k metal gate技术，使得28nm工艺的漏电功耗比40nm工艺的漏电功耗要小很多，这里就不再详述。
Datapath功耗优化
Datapath会消耗大量的动态功耗，因为一般此类电路的翻转率都比较高，大量的组合逻辑会产生很多glitch，也会消耗大量功耗。如何减少datapath功耗对DSP类芯片意义重大，下面介绍一些目前看到的方法。
按照datapath编码风格进行编码
一般我们用到一个乘法器或加法器的时候，可能会选择手工例化designware库，这这样会阻止综合的优化，因为一般运算电路都是连续运算的，比如连乘，连加，或者连续的乘加等，综合工具可以把这些连续的运算统一优化，得到比较好的QOR，如果都是单独例化designware则会阻碍这种优化。当然datapath优化还有很多其他方面的限制，比如有符号数和无符号数运算不能一起优化，优化不能跨域模块层次和寄存器等，具体请参考synopsys datapath coding style文档。
选择transition probability低的cell
因为datapath路径有大量的组合逻辑，每个cell的transition probability是有区别的，transition probability定义如下图所示。
 
信号的翻转概率能够用来有效的优化switching power。
选择不同的datapath结构
不同的datapath结构对电路的面积，速度和功耗有不同的影响。比如选择快的电路结构可以用驱动能力比较小的cell，或者HVT cell来降低datapath的功耗，如下图所示。
 
 
合理安排运算顺序
合理安排运算顺序及结构，使高翻转的信号经过尽量少的运算单元，如下图所示，可以降低datapath的动态功耗（需要翻转率文件支持）。
 
Datapath gating
这种结构类似于原来的操作数隔离，即在操作数不变的情况下把它gating掉，阻止了无效翻转的传播，可以把gating加在外部，或者集成在datapath内部，如下图所示。
 
减少datapath的glitch
Datapath中由于存在大量的组合逻辑运算单元，实际电路工作中会产生大量的glitch，glitch功耗是datapath功耗的重要组成部分，有时候会占整个datapath动态功耗的30%以上。我们可以通过以下几种方法减少glitch：
1）	Path balancing是最有效的减少glitch的方法，但这种方法在整个流程中实用性不是很强，但它可以指导我们选择比较平衡结构的电路结构减少glitch，比如booth encoder。
2）	在可能的情况下，尽量插入寄存器，可以有效阻止glitch的传播
3）	并行拓扑结构一般比链式拓扑结构传播更少的glitch（tree vs chain topology）。
4）	某些复杂的cell有较好的balanced delay，可以有效的滤除glitches，比如4:2 compressor，XOR-baseed booth cells等，如下图所示，它们可以做成为一个集成的cell。
 
讲到这里，大家可能会问，上面的这些方法好像都不怎么好操作啊，说的很对，上面除了按datapath的编码风格进行编码，安排高翻转率的信号最后参与运算外，其他几条确实不太好操作。
最近synopsys针对designware库进行了专门的优化，提供了minpower designware库，在不改变现有流程的情况下，可以尽力用上面介绍的方法去优化datapath功耗。用Minpower designware库流程简单脚本如下图所示。
 
首先需要在synthetic_library变量中指定使用dw_minpower.sldb库，读入switching activity文件，这个可以指导工具利用上面这些方法，更好的优化功耗，接着是设置功耗约束和使能datapath gating，最后用compile_ultra进行综合。
当然minpower的实际效果和Tool capability, Coding style, Design architecture, Cell library, Timing constraint等几个因素相关，在datapath比较多的设计中尽量应用。
电压控制
     前面介绍了这么多，决定power的一个最重要的因素还没说，就是电压，要知道动态功耗与电压的平方成正比，漏电功耗也由电压和漏电电流决定。电压控制有多种方式，最常用的比如说Multi-supply voltage(Voltage islands)，就是在一块芯片中性能高的模块用高的供电电压，性能要求低的模块用低的供电电压，从而达到降低功耗的目的。AVS（Adaptive voltage scaling）是根据电路的工作模式，工作状态，工艺条件等因素动态的调整供电电压，使电路工作在最低的电压条件下。Power gating就是把不工作的模块的电源关掉，达到同时降低动态功耗和静态功耗的目的，Power gating在海思已经用的比较普遍了，在传送的SD8606中也有应用。
电压控制技术涉及到很多问题，比如不同电压域之间信号交互等问题，需要完整的设计流程及方法，这里请参考下面两个关于电压控制的介绍性文档。
 
 
（AVS为无线同事姚辉共享）

流程中降功耗的其他机会点
在电路实现和后端实现的流程中，还有没有其他降功耗的机会点了，下面结合项目的具体实践，介绍一些方法和思路。
	识别高扇出全局控制信号
传统的同步设计流程的基本原则是最好所有信号都是同步的，当信号跨越时钟域时，都先经过同步处理，但在很多情况下，这些信号并不需要做同步处理，这种情况是典型的过设计。在SD8XXX项目中就有这样的特点，有很多全局的控制信号扇出很大，这些信号最开始基本都做了同步处理，这样在综合阶段，对于这样的信号为了满足时序要求，会插入大量的buffer做时序balance，从而增加了很多功耗，并且后端时序很难收敛。针对这种情况，我们识别了不需要同步的全局控制信号，RTL设计阶段不做同步，或者在综合阶段设置false path，使这些信号的扇出不会因为满足时序而插入大量的buffer，从而减低功耗。对于需要同步的全局控制信号，我们尽量采用复制寄存器的方法，使它的load分散到一些小树上去，这样时序更容易满足。
	综合阶段设置功耗约束
现在综合工具都支持对功耗进行约束，比如在DC中，可以通过命令set_max_dynamic_power/set_max_leakage_power/set_max_total_power分别对动态功耗，漏电功耗和总功耗进行约束，在进行功耗约束优化时，最好能读入信号的翻转率文件，这样能达到更好的效果。综合工具对约束的优先级从高到低依次为timing>power>area。
	综合时设置常数优化
通过综合工具如下变量设置，可以优化常数寄存器，并且能把常数传播，优化后面的逻辑。
 
	优化整体Floorplan
合理的整体Floorplan对整体功耗影响很大，要尽量使模块的物理形状方正，顶层数据流规整。在SD8XXX项目中，最初的Floorplan如下图所示。
 
从图中可以看出，很多模块是细长条形状的，容易造成布线拥塞，走线变长，电容增大，timing不容易收敛而插入更多的buffer，后端实现时增加很多功耗。经过调整的Floorplan如下图所示。
 
调整后子模块形状变得规整方正，这样不论对时序，绕线和功耗都是有好处的，这样后端实现增加的功耗才在一个合理的范围内。
	精细化Subchip内部Floorplan
对于每个Subchip，设计者需要提供Subchip内部各底层模块的关系图给Vendor，为Vendor做布局布线提供参考。Vendor做完每个Subchip的布局布线后，会返回给项目组Def文件，进行Floorplan的review工作，项目组对Floorplan提出改进建议，Vendor再对Floorplan进行微调。经过几轮这样的迭代，可以保证Subchip内部Floorplan相对比较合理，减少后端实现增加的代价。
	减小后端实现的IR drop
当整个芯片最大的IR drop较小时，可以通过控制电源的精度，为芯片提供一个相对较低的电压，从而保证大部分Cell工作在一个较低的电压上（当然要比最低的电压高），来降低芯片整体消耗的功耗。当然最大的IR drop在满足相关标准的情况下，只能要求Vendor尽量做小。
电路实现和后端实现流程随想
先介绍一下缩略语。
DC ：Design compiler，synopsys综合工具。
RC ：RTL compiler，cadence综合工具。
ICC ：IC compiler，synopsys 布局布线工具。
SOCE：SOC encounter，cadence布局布线工具。
现在海思综合主要用DC，平台有些项目在用RC，在网上看到国外用RC工具做综合的也不少，每种工具都有它各自的特点和优势，某些模块用DC工具能得到质量较好的网表，另一些模块可能用RC综合能得到质量较好的网表，同理布局布线工具也一样。在要求设计精益化，实现精益化的项目中，有必要尝试不同的工具流程，下面对流程做下简单介绍。
现有流程
现有流程如下图所示。
 
现有流程主要是用DC进行综合，用ICC或者SOCE进行布局布线（用那种工具由Vendor或者COT后端团队决定）。
SD8XXX实践过的流程
SD8XXX实践过的流程如下图所示。
 
SD8XXX项目由于功耗方面的压力，Vendor在做布局布线的时候两种工具都测试过，最后选择功耗小的版本，这种流程粗略看来后端工作量增加一倍。
理想流程
根据不同工具的组合，理想流程如下图所示。
 
根据不同工具的特点，PR输出有四种版本的网表，选择功耗最低的版本，但理想流程后端工作量会是原来的四倍甚至还多，后端应该不是很能接受。
理想流程之简化版
理想流程简化版如下图所示。
 
简化版流程在综合网表阶段进行一个选择，选择DC和RC中较优化的版本作为PR工具的入口网表，再分别用ICC和SOCE做布局布线，最后选择功耗最低的版本。这样综合和PR的工作量基本都是原来的2倍。

功耗的压力要求我们在每个阶段多做尝试，就是祝少所说的“抠门”（精细化设计）。

